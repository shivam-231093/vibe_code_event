import {
  require_react
} from "./chunk-UGC3UZ7L.js";
import {
  __commonJS
} from "./chunk-G3PMV62Z.js";

// node_modules/react-timer-hook/dist/index.js
var require_dist = __commonJS({
  "node_modules/react-timer-hook/dist/index.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "object" == typeof module ? module.exports = t(require_react()) : "function" == typeof define && define.amd ? define(["react"], t) : "object" == typeof exports ? exports["react-timer-hook"] = t(require_react()) : e["react-timer-hook"] = t(e.react);
    }("undefined" != typeof self ? self : exports, (e) => (() => {
      "use strict";
      var t = { 155: (t2) => {
        t2.exports = e;
      } }, s = {};
      function i(e2) {
        var o2 = s[e2];
        if (void 0 !== o2) return o2.exports;
        var r2 = s[e2] = { exports: {} };
        return t[e2](r2, r2.exports, i), r2.exports;
      }
      i.d = (e2, t2) => {
        for (var s2 in t2) i.o(t2, s2) && !i.o(e2, s2) && Object.defineProperty(e2, s2, { enumerable: true, get: t2[s2] });
      }, i.o = (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2), i.r = (e2) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
      };
      var o = {};
      i.r(o), i.d(o, { useStopwatch: () => u, useTime: () => d, useTimer: () => m });
      var r = i(155);
      class n {
        static getTimeFromMilliseconds(e2, t2 = true) {
          const s2 = t2 ? Math.ceil(e2 / 1e3) : Math.floor(e2 / 1e3), i2 = Math.floor(s2 / 86400), o2 = Math.floor(s2 % 86400 / 3600), r2 = Math.floor(s2 % 3600 / 60), n2 = Math.floor(s2 % 60);
          return { totalMilliseconds: e2, totalSeconds: s2, milliseconds: Math.floor(e2 % 1e3), seconds: n2, minutes: r2, hours: o2, days: i2 };
        }
        static getMillisecondsFromExpiry(e2) {
          const t2 = (/* @__PURE__ */ new Date()).getTime(), s2 = (null == e2 ? void 0 : e2.getTime()) - t2;
          return s2 > 0 ? s2 : 0;
        }
        static getMillisecondsFromPrevTime(e2) {
          const t2 = (/* @__PURE__ */ new Date()).getTime() - e2;
          return t2 > 0 ? t2 : 0;
        }
        static getMillisecondsFromTimeNow() {
          const e2 = /* @__PURE__ */ new Date();
          return e2.getTime() - 60 * e2.getTimezoneOffset() * 1e3;
        }
        static getFormattedTimeFromMilliseconds(e2, t2) {
          const { milliseconds: s2, seconds: i2, minutes: o2, hours: r2 } = n.getTimeFromMilliseconds(e2);
          let l2 = "", a2 = r2;
          return "12-hour" === t2 && (l2 = r2 >= 12 ? "pm" : "am", a2 = r2 % 12), { milliseconds: s2, seconds: i2, minutes: o2, hours: a2, ampm: l2 };
        }
      }
      class l {
        static expiryTimestamp(e2) {
          const t2 = new Date(e2).getTime() > 0;
          return t2 || console.warn("react-timer-hook: { useTimer } Invalid expiryTimestamp settings", e2), t2;
        }
        static onExpire(e2) {
          const t2 = e2 && "function" == typeof e2;
          return e2 && !t2 && console.warn("react-timer-hook: { useTimer } Invalid onExpire settings function", e2), t2;
        }
      }
      function a(e2, t2) {
        const s2 = (0, r.useRef)(e2);
        (0, r.useEffect)(() => {
          s2.current = e2;
        }), (0, r.useEffect)(() => {
          if (!t2) return () => {
          };
          const e3 = setInterval(() => {
            var e4;
            null === (e4 = null == s2 ? void 0 : s2.current) || void 0 === e4 || e4.call(s2);
          }, t2);
          return () => clearInterval(e3);
        }, [t2]);
      }
      const c = 1e3;
      function m({ expiryTimestamp: e2, onExpire: t2 = () => {
      }, autoStart: s2 = true, interval: i2 = c }) {
        const [o2, m2] = (0, r.useState)(e2), [u2, d2] = (0, r.useState)(n.getMillisecondsFromExpiry(o2)), [g, f] = (0, r.useState)(s2), [p, T] = (0, r.useState)(s2), [M, y] = (0, r.useState)(i2), v = (0, r.useCallback)(() => {
          l.onExpire(t2) && t2(), f(false), y(null);
        }, [t2]), b = (0, r.useCallback)(() => {
          f(false);
        }, []), x = (0, r.useCallback)((e3, t3 = true) => {
          y(i2), T(t3), f(t3), m2(e3), d2(n.getMillisecondsFromExpiry(e3));
        }, [i2]), F = (0, r.useCallback)(() => {
          const e3 = /* @__PURE__ */ new Date();
          e3.setMilliseconds(e3.getMilliseconds() + u2), x(e3);
        }, [u2, x]), S = (0, r.useCallback)(() => {
          p ? (d2(n.getMillisecondsFromExpiry(o2)), f(true)) : F();
        }, [o2, p, F]);
        return a(() => {
          const e3 = n.getMillisecondsFromExpiry(o2);
          d2(e3), e3 <= 0 ? v() : M && e3 < M && y(e3);
        }, g ? M : null), (0, r.useEffect)(() => {
          l.expiryTimestamp(o2);
        }, [o2]), Object.assign(Object.assign({}, n.getTimeFromMilliseconds(u2)), { start: S, pause: b, resume: F, restart: x, isRunning: g });
      }
      function u({ autoStart: e2 = true, offsetTimestamp: t2, interval: s2 = c } = {}) {
        const i2 = t2 ? n.getMillisecondsFromExpiry(t2) : 0, [o2, l2] = (0, r.useState)((/* @__PURE__ */ new Date()).getTime() - new Date(i2).getTime()), [m2, u2] = (0, r.useState)(n.getMillisecondsFromPrevTime(o2 || 0)), [d2, g] = (0, r.useState)(e2), f = c - m2 % c, [p, T] = (0, r.useState)(s2 < f ? s2 : f);
        a(() => {
          p !== s2 && T(s2), u2(n.getMillisecondsFromPrevTime(o2));
        }, d2 ? p : null);
        const M = (0, r.useCallback)(() => {
          l2((/* @__PURE__ */ new Date()).getTime() - new Date(m2).getTime()), g(true);
        }, [m2]), y = (0, r.useCallback)(() => {
          d2 && (u2(n.getMillisecondsFromPrevTime(o2)), g(false));
        }, [o2, d2]), v = (0, r.useCallback)((e3, t3 = true) => {
          const i3 = e3 ? n.getMillisecondsFromExpiry(e3) : 0, o3 = (/* @__PURE__ */ new Date()).getTime() - new Date(i3).getTime(), r2 = n.getMillisecondsFromPrevTime(o3), a2 = c - r2 % c;
          l2(o3), u2(r2), T(s2 < a2 ? s2 : a2), g(t3);
        }, [s2]);
        return Object.assign(Object.assign({}, n.getTimeFromMilliseconds(m2, false)), { start: M, pause: y, reset: v, isRunning: d2 });
      }
      function d({ format: e2, interval: t2 = c } = {}) {
        const [s2, i2] = (0, r.useState)(n.getMillisecondsFromTimeNow());
        return a(() => {
          i2(n.getMillisecondsFromTimeNow());
        }, t2), Object.assign({}, n.getFormattedTimeFromMilliseconds(s2, e2));
      }
      return o;
    })());
  }
});
export default require_dist();
//# sourceMappingURL=react-timer-hook.js.map
